/*
    继承中的构造和析构顺序
        先构造父类，再构造子类
        析构顺序与构造相反




    继承下来的同名属性和函数同样可以访问
    如果通过子类对象 访问到父类中同名成员，需要加作用域
    
        s.Base::m_A
        s.Bace::func()

    如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏父类中所有同名成员函数
    如果想访问被隐藏的函数，需要添加作用域


    继承中的同名静态成员处理方式
        子类出现和父类同名静态成员函数，也会隐藏父类中所有同名成员函数
        如果想访问父类中被隐藏同名成员，需要加作用域

    通过对象访问
        s.Base::func()
    通过类名访问
        Son::Base::func()


*/

#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{


    
    return 0;
}

















